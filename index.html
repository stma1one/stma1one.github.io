<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>סימולטור מבנה נתונים לפי מחלקות בגרות</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- React & Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
      body { font-family: 'Inter', sans-serif; }
      pre, code { font-family: 'JetBrains Mono', monospace; direction: ltr; }
      /* Force LTR for code blocks even in RTL document */
      .font-mono { direction: ltr; }
    </style>

    <!-- Basic Protection Script -->
    <script>
      document.addEventListener('contextmenu', event => event.preventDefault());
      document.onkeydown = function(e) {
        if(e.key == 123) return false; // F12
        if(e.ctrlKey && e.shiftKey && e.key == 'I') return false; // Ctrl+Shift+I
        if(e.ctrlKey && e.shiftKey && e.key === 'C') return false; // Ctrl+Shift+C
        if(e.ctrlKey && e.shiftKey && e.key === 'J') return false; // Ctrl+Shift+J
        if(e.ctrlKey && e.key === 'U') return false; // Ctrl+U
      }
    </script>

    <!-- Import Map to handle external libraries -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "framer-motion": "https://esm.sh/framer-motion@10.16.4?external=react,react-dom",
    "lucide-react": "https://esm.sh/lucide-react@0.292.0?external=react,react-dom",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
<body class="bg-slate-50">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      import React, { useState, useEffect } from 'react';
      import { createRoot } from 'react-dom/client';
      import { motion, AnimatePresence } from 'framer-motion';
      import { 
        Play, Pause, SkipBack, SkipForward, ArrowRight, ArrowLeft, 
        ArrowDownToLine, Layers, Code, PlusCircle, Trash2, Hash, 
        Network, ZoomIn, ZoomOut, Minimize2, Maximize2, Construction 
      } from 'lucide-react';

      // ==========================================
      // CONSTANTS
      // ==========================================
      const COLORS = {
        head: "text-purple-600 border-purple-600 bg-purple-100",
        lst: "text-indigo-600 border-indigo-600 bg-indigo-100",
        current: "text-blue-600 border-blue-600 bg-blue-100",
        prev: "text-orange-600 border-orange-600 bg-orange-100",
        newNode: "text-green-600 border-green-600 bg-green-100",
        top: "text-pink-600 border-pink-600 bg-pink-100",
        root: "text-purple-600 border-purple-600 bg-purple-100",
        temp: "text-slate-500 border-slate-500 bg-slate-200", 
        default: "bg-white border-slate-300 text-slate-700"
      };

      const DATA_STRUCTURES = {
        LINKED_LIST: 'Node<T>',
        STACK: 'Stack<T>',
        QUEUE: 'Queue<T>',
        BINARY_TREE: 'BinNode<T>'
      };

      const BTN_STYLES = {
        primary: "px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded text-xs font-bold transition-colors shadow-sm w-full flex items-center justify-center gap-2",
      };

      const OPS_CONFIG = {
        [DATA_STRUCTURES.LINKED_LIST]: [
          { value: 'addFirst', label: 'Add First', params: ['val'] },
          { value: 'addLast', label: 'Add Last', params: ['val'] },
          { value: 'addAfter', label: 'Add After', params: ['target', 'val'] },
          { value: 'addBefore', label: 'Add Before', params: ['target', 'val'] },
          { value: 'find', label: 'Find', params: ['target'] },
          { value: 'delete', label: 'Delete', params: ['target'] },
          { value: 'count', label: 'Count (Iterative)', params: [] },
          { value: 'recursiveCount', label: 'Count (Recursive)', params: [] },
        ],
        [DATA_STRUCTURES.STACK]: [
          { value: 'push', label: 'Push', params: ['val'] },
          { value: 'pop', label: 'Pop', params: [] },
          { value: 'removeVal', label: 'Remove (Val)', params: ['target'] },
          { value: 'removeLast', label: 'Remove Last', params: [] },
          { value: 'count', label: 'Count (Static)', params: [] },
          { value: 'recursiveCount', label: 'Count (Recursive)', params: [] },
        ],
        [DATA_STRUCTURES.QUEUE]: [
           { value: 'insert', label: 'Insert', params: ['val'] },
           { value: 'remove', label: 'Remove', params: [] },
           { value: 'removeVal', label: 'Remove (Val)', params: ['target'] },
           { value: 'removeLast', label: 'Remove Last', params: [] },
           { value: 'count', label: 'Count (Static)', params: [] },
           { value: 'recursiveCount', label: 'Count (Recursive)', params: [] },
        ],
        [DATA_STRUCTURES.BINARY_TREE]: [
          { value: 'insert', label: 'Insert (BST)', params: ['val'] },
          { value: 'find', label: 'Find', params: ['target'] },
          { value: 'count', label: 'Count Nodes', params: [] },
          { value: 'countLeaves', label: 'Count Leaves', params: [] },
        ]
      };

      const CODE_SNIPPETS = {
        [DATA_STRUCTURES.LINKED_LIST]: {
          addFirst: { 
            java: `public static Node<Integer> addFirst(Node<Integer> lst, int val) {\n  Node<Integer> p = new Node<Integer>(val);\n  p.setNext(lst);\n  return p;\n}`, 
            csharp: `public static Node<int> AddFirst(Node<int> lst, int val) {\n  Node<int> p = new Node<int>(val);\n  p.SetNext(lst);\n  return p;\n}` 
          },
          addLast: { 
            java: `public static Node<Integer> addLast(Node<Integer> lst, int val) {\n  if (lst == null) \n    return new Node<Integer>(val);\n  Node<Integer> p = lst;\n  while (p.getNext() != null) \n    p = p.getNext();\n  p.setNext(new Node<Integer>(val));\n  return lst;\n}`, 
            csharp: `public static Node<int> AddLast(Node<int> lst, int val) {\n  if (lst == null) \n    return new Node<int>(val);\n  Node<int> p = lst;\n  while (p.GetNext() != null) \n    p = p.GetNext();\n  p.SetNext(new Node<int>(val));\n  return lst;\n}` 
          },
          find: { 
            java: `public static boolean find(Node<Integer> lst, int target) {\n  Node<Integer> p = lst;\n  while (p != null) {\n    if (p.getValue() == target) \n      return true;\n    p = p.getNext();\n  }\n  return false;\n}`, 
            csharp: `public static bool Find(Node<int> lst, int target) {\n  Node<int> p = lst;\n  while (p != null) {\n    if (p.GetValue() == target) \n      return true;\n    p = p.GetNext();\n  }\n  return false;\n}` 
          },
          delete: { 
            java: `public static Node<Integer> delete(Node<Integer> lst, int target) {\n  if (lst == null) \n    return null;\n  if (lst.getValue() == target) \n    return lst.getNext();\n  Node<Integer> prev = lst;\n  while (prev.getNext() != null) {\n    if (prev.getNext().getValue() == target) {\n       prev.setNext(prev.getNext().getNext());\n       return lst;\n    }\n    prev = prev.getNext();\n  }\n  return lst;\n}`, 
            csharp: `public static Node<int> Delete(Node<int> lst, int target) {\n  if (lst == null) \n    return null;\n  if (lst.GetValue() == target) \n    return lst.GetNext();\n  Node<int> prev = lst;\n  while (prev.GetNext() != null) {\n    if (prev.GetNext().GetValue() == target) {\n       prev.SetNext(prev.GetNext().GetNext());\n       return lst;\n    }\n    prev = prev.GetNext();\n  }\n  return lst;\n}` 
          },
          count: { 
            java: `public static int count(Node<Integer> lst) {\n  int c = 0;\n  for (Node<Integer> p = lst; p != null; p = p.getNext())\n    c++;\n  return c;\n}`, 
            csharp: `public static int Count(Node<int> lst) {\n  int c = 0;\n  for (Node<int> p = lst; p != null; p = p.GetNext())\n    c++;\n  return c;\n}` 
          },
          recursiveCount: { 
            java: `public static int recursiveCount(Node<Integer> p) {\n  if (p == null) \n    return 0;\n  return 1 + recursiveCount(p.getNext());\n}`, 
            csharp: `public static int RecursiveCount(Node<int> p) {\n  if (p == null) \n    return 0;\n  return 1 + RecursiveCount(p.GetNext());\n}` 
          },
          addAfter: { 
            java: `public static void addAfter(Node<Integer> lst, int target, int val) {\n  Node<Integer> p = lst;\n  while (p != null) {\n    if (p.getValue() == target) {\n       Node<Integer> temp = new Node<Integer>(val);\n       temp.setNext(p.getNext());\n       p.setNext(temp);\n       return;\n    }\n    p = p.getNext();\n  }\n}`, 
            csharp: `public static void AddAfter(Node<int> lst, int target, int val) {\n  Node<int> p = lst;\n  while (p != null) {\n    if (p.getValue() == target) {\n       Node<int> temp = new Node<int>(val);\n       temp.SetNext(p.GetNext());\n       p.SetNext(temp);\n       return;\n    }\n    p = p.GetNext();\n  }\n}` 
          },
          addBefore: { 
            java: `public static Node<Integer> addBefore(Node<Integer> lst, int target, int val) {\n  if (lst == null) \n    return null;\n  if (lst.getValue() == target) {\n    Node<Integer> p = new Node<Integer>(val);\n    p.setNext(lst);\n    return p;\n  }\n  Node<Integer> prev = lst;\n  while (prev.getNext() != null) {\n    if (prev.getNext().getValue() == target) {\n      Node<Integer> temp = new Node<Integer>(val);\n      temp.setNext(prev.getNext());\n      prev.setNext(temp);\n      return lst;\n    }\n    prev = prev.getNext();\n  }\n  return lst;\n}`, 
            csharp: `public static Node<int> AddBefore(Node<int> lst, int target, int val) {\n  if (lst == null) \n    return null;\n  if (lst.GetValue() == target) {\n    Node<int> p = new Node<int>(val);\n    p.SetNext(lst);\n    return p;\n  }\n  Node<int> prev = lst;\n  while (prev.GetNext() != null) {\n    if (prev.GetNext().GetValue() == target) {\n      Node<int> temp = new Node<int>(val);\n      temp.SetNext(prev.GetNext());\n      prev.SetNext(temp);\n      return lst;\n    }\n    prev = prev.GetNext();\n  }\n  return lst;\n}` 
          }
        },
        [DATA_STRUCTURES.STACK]: {
          push: { 
            java: `public static void push(Stack<Integer> s, int val) {\n  s.push(val);\n}`, 
            csharp: `public static void Push(Stack<int> s, int val) {\n  s.Push(val);\n}` 
          },
          pop: { 
            java: `public static int pop(Stack<Integer> s) {\n  return s.pop();\n}`, 
            csharp: `public static int Pop(Stack<int> s) {\n  return s.Pop();\n}` 
          },
          count: { 
            java: `public static int count(Stack<Integer> s) {\n  Stack<Integer> temp = new Stack<Integer>();\n  int c = 0;\n  while (!s.isEmpty()) {\n    temp.push(s.pop());\n    c++;\n  }\n  while (!temp.isEmpty()) \n    s.push(temp.pop());\n  return c;\n}`, 
            csharp: `public static int Count(Stack<int> s) {\n  Stack<int> temp = new Stack<int>();\n  int c = 0;\n  while (!s.IsEmpty()) {\n    temp.Push(s.Pop());\n    c++;\n  }\n  while (!temp.IsEmpty()) \n    s.Push(temp.Pop());\n  return c;\n}` 
          },
          removeVal: { 
            java: `public static void remove(Stack<Integer> s, int val) {\n  Stack<Integer> temp = new Stack<Integer>();\n  while(!s.isEmpty()) {\n    int x = s.pop();\n    if (x != val) \n      temp.push(x);\n  }\n  while(!temp.isEmpty()) \n    s.push(temp.pop());\n}`, 
            csharp: `public static void Remove(Stack<int> s, int val) {\n  Stack<int> temp = new Stack<int>();\n  while(!s.IsEmpty()) {\n    int x = s.Pop();\n    if (x != val) \n      temp.Push(x);\n  }\n  while(!temp.IsEmpty()) \n    s.Push(temp.Pop());\n}` 
          },
          removeLast: { 
            java: `public static void removeLast(Stack<Integer> s) {\n  Stack<Integer> temp = new Stack<Integer>();\n  while(!s.isEmpty()) \n    temp.push(s.pop());\n  if (!temp.isEmpty()) \n    temp.pop();\n  while(!temp.isEmpty()) \n    s.push(temp.pop());\n}`, 
            csharp: `public static void RemoveLast(Stack<int> s) {\n  Stack<int> temp = new Stack<int>();\n  while(!s.IsEmpty()) \n    temp.Push(s.Pop());\n  if (!temp.IsEmpty()) \n    temp.Pop();\n  while (!temp.IsEmpty()) \n    s.Push(temp.Pop());\n}` 
          },
          recursiveCount: { 
            java: `public static int recursiveCount(Stack<Integer> s) {\n  if (s.isEmpty()) \n    return 0;\n  int temp = s.pop();\n  int res = 1 + recursiveCount(s);\n  s.push(temp);\n  return res;\n}`, 
            csharp: `public static int RecursiveCount(Stack<int> s) {\n  if (s.IsEmpty()) \n    return 0;\n  int temp = s.Pop();\n  int res = 1 + RecursiveCount(s);\n  s.Push(temp);\n  return res;\n}` 
          }
        },
        [DATA_STRUCTURES.QUEUE]: {
          insert: { 
            java: `public static void insert(Queue<Integer> q, int val) {\n  q.insert(val);\n}`, 
            csharp: `public static void Insert(Queue<int> q, int val) {\n  q.Insert(val);\n}` 
          },
          remove: { 
            java: `public static int remove(Queue<Integer> q) {\n  return q.remove();\n}`, 
            csharp: `public static int Remove(Queue<int> q) {\n  return q.Remove();\n}` 
          },
          count: { 
            java: `public static int count(Queue<Integer> q) {\n  int c = 0;\n  Queue<Integer> temp = new Queue<Integer>();\n  while(!q.isEmpty()) {\n     temp.insert(q.remove());\n     c++;\n  }\n  while(!temp.isEmpty()) \n    q.insert(temp.remove());\n  return c;\n}`, 
            csharp: `public static int Count(Queue<int> q) {\n  Queue<int> temp = new Queue<int>();\n  int c = 0;\n  while(!q.IsEmpty()) {\n     temp.Insert(q.Remove());\n     c++;\n  }\n  while(!temp.IsEmpty()) \n    q.Insert(temp.Remove());\n  return c;\n}` 
          },
          removeVal: { 
            java: `public static void remove(Queue<Integer> q, int val) {\n  Queue<Integer> temp = new Queue<Integer>();\n  while(!q.isEmpty()) {\n    int x = q.remove();\n    if (x != val) \n      temp.insert(x);\n  }\n  while(!temp.isEmpty()) \n    q.insert(temp.remove());\n}`, 
            csharp: `public static void Remove(Queue<int> q, int val) {\n  Queue<int> temp = new Queue<int>();\n  while(!q.IsEmpty()) {\n    int x = q.Remove();\n    if (x != val) \n      temp.Insert(x);\n  }\n  while(!temp.IsEmpty()) \n    q.Insert(temp.Remove());\n}` 
          },
          removeLast: { 
            java: `public static void removeLast(Queue<Integer> q) {\n  Queue<Integer> temp = new Queue<Integer>();\n  while(!q.isEmpty()) \n    temp.insert(q.remove());\n  while(!temp.isEmpty()) {\n    int x = temp.remove();\n    if(!temp.isEmpty()) \n      q.insert(x);\n  }\n}`, 
            csharp: `public static void RemoveLast(Queue<int> q) {\n  Queue<int> temp = new Queue<int>();\n  while(!q.IsEmpty()) \n    temp.Insert(q.Remove());\n  while(!temp.IsEmpty()) {\n    int x = temp.Remove();\n    if(!temp.IsEmpty()) \n      q.Insert(x);\n  }\n}` 
          },
          recursiveCount: { 
            java: `public static int recursiveCount(Queue<Integer> q) {\n  if (q.isEmpty()) \n    return 0;\n  int temp = q.remove();\n  int res = 1 + recursiveCount(q);\n  q.insert(temp);\n  return res;\n}`, 
            csharp: `public static int RecursiveCount(Queue<int> q) {\n  if (q.IsEmpty()) \n    return 0;\n  int temp = q.Remove();\n  int res = 1 + RecursiveCount(q);\n  q.Insert(temp);\n  return res;\n}` 
          }
        },
        [DATA_STRUCTURES.BINARY_TREE]: {
          insert: { 
            java: `public static BinNode<Integer> insert(BinNode<Integer> root, int val) {\n  if (root == null) \n    return new BinNode<Integer>(null, val, null);\n  if (val < root.getValue()) \n      root.setLeft(insert(root.getLeft(), val));\n  else \n      root.setRight(insert(root.getRight(), val));\n  return root;\n}`, 
            csharp: `public static BinNode<int> Insert(BinNode<int> root, int val) {\n  if (root == null) \n    return new BinNode<int>(null, val, null);\n  if (val < root.GetValue()) \n      root.SetLeft(Insert(root.GetLeft(), val));\n  else \n      root.SetRight(Insert(root.GetRight(), val));\n  return root;\n}` 
          },
          find: { 
            java: `public static boolean find(BinNode<Integer> root, int x) {\n  if (root == null) \n    return false;\n  if (root.getValue() == x) \n    return true;\n  return find(root.getLeft(), x) || find(root.getRight(), x);\n}`, 
            csharp: `public static bool Find(BinNode<int> root, int x) {\n  if (root == null) \n    return false;\n  if (root.GetValue() == x) \n    return true;\n  return Find(root.GetLeft(), x) || Find(root.GetRight(), x);\n}` 
          },
          count: { 
            java: `public static int count(BinNode<Integer> root) {\n  if (root == null) \n    return 0;\n  return 1 + count(root.getLeft()) + count(root.getRight());\n}`, 
            csharp: `public static int Count(BinNode<int> root) {\n  if (root == null) \n    return 0;\n  return 1 + Count(root.GetLeft()) + Count(root.GetRight());\n}` 
          },
          countLeaves: { 
            java: `public static int countLeaves(BinNode<Integer> root) {\n  if (root == null) \n    return 0;\n  if (!root.hasLeft() && !root.hasRight()) \n    return 1;\n  return countLeaves(root.getLeft()) + countLeaves(root.getRight());\n}`, 
            csharp: `public static int CountLeaves(BinNode<int> root) {\n  if (root == null) \n    return 0;\n  if (!root.HasLeft() && !root.HasRight()) \n    return 1;\n  return CountLeaves(root.GetLeft()) + CountLeaves(root.GetRight());\n}` 
          }
        }
      };

      // ==========================================
      // ENGINE
      // ==========================================
      const uid = () => Math.random().toString(36).substr(2, 9);
      const generateInitialList = () => [];
      const generateRandomList = (count = 5) => Array.from({ length: count }, (_, i) => ({ id: uid(), value: Math.floor(Math.random() * 99) + 1 })).map((n, i, arr) => ({ ...n, next: arr[i + 1]?.id || null }));

      class SnapshotBuilder {
        constructor(initialNodes, type) {
          this.frames = [];
          this.nodes = JSON.parse(JSON.stringify(initialNodes));
          this.detachedNodes = [];
          this.mainStack = [...this.nodes]; 
          this.tempStack = []; 
          this.type = type;
          this.pointers = {};
          this.variables = {}; 
          this.miniMap = { root: null, currentId: null }; 
          this.message = "";
          this.returnValue = null;
          this.highlightLine = 0;
          this.tempReturnValue = null;
        }

        syncVisualNodes() {
            const visualMain = this.mainStack.map(n => ({ ...n, isTemp: false }));
            const visualTemp = this.tempStack.map(n => ({ ...n, isTemp: true }));
            this.nodes = [...visualMain, ...visualTemp];
        }

        addCallToMap(id, label, parentId, paramValue = null) {
            const newNode = { id, label, children: [], status: 'active', parentId, value: null, paramValue, locals: {} };
            if (!this.miniMap.root) this.miniMap.root = newNode;
            else {
                const add = (node) => {
                    if (node.id === parentId) { node.children.push(newNode); return true; }
                    for (const child of node.children) if (add(child)) return true;
                    return false;
                };
                add(this.miniMap.root);
            }
            this.miniMap.currentId = id;
        }

        updateCallStatus(id, status, value = null) {
            const update = (node) => {
                if (node.id === id) { node.status = status; if (value !== null) node.value = value; return true; }
                for (const child of node.children) if (update(child)) return true;
                return false;
            };
            update(this.miniMap.root);
            if (status === 'returned' && id === this.miniMap.currentId) {
                const findNode = (n) => { if (n.id === id) return n; for (const c of n.children) { const res = findNode(c); if (res) return res; } return null; };
                const n = findNode(this.miniMap.root);
                if (n && n.parentId) this.miniMap.currentId = n.parentId;
            }
        }

        updateCallLocal(id, key, value) {
            const update = (node) => {
                if (node.id === id) { 
                    if (!node.locals) node.locals = {};
                    node.locals[key] = value;
                    return true; 
                }
                for (const child of node.children) if (update(child)) return true;
                return false;
            };
            update(this.miniMap.root);
        }

        addFrame(line, msg = "") {
          if (this.type === DATA_STRUCTURES.STACK) this.syncVisualNodes();
          this.frames.push({
            nodes: JSON.parse(JSON.stringify(this.nodes)), 
            detachedNodes: JSON.parse(JSON.stringify(this.detachedNodes)),
            pointers: { ...this.pointers },
            variables: { ...this.variables },
            miniMap: JSON.parse(JSON.stringify(this.miniMap)),
            highlightLine: line,
            message: msg || this.message,
            returnValue: this.returnValue
          });
        }

        setPointer(name, targetId) {
          if (targetId === null) delete this.pointers[name];
          else this.pointers[name] = targetId;
        }

        // --- Stack Operations ---
        simulateStackPush(val) { 
            this.addFrame(1); 
            const newNode = { id: uid(), value: val, next: null, isNew: true }; 
            this.mainStack.push(newNode); 
            this.addFrame(2, "s.push(val)"); 
            delete newNode.isNew; 
            return this.frames; 
        }
        
        simulateStackPop() { 
            this.addFrame(1); 
            if (this.mainStack.length === 0) { 
                this.addFrame(2); 
                return this.frames; 
            } 
            const val = this.mainStack[this.mainStack.length - 1].value; 
            this.mainStack[this.mainStack.length - 1].isDeleted = true; 
            this.addFrame(2); 
            this.mainStack.pop(); 
            this.returnValue = val; 
            this.addFrame(2); 
            return this.frames; 
        }

        simulateStackCount() {
          this.addFrame(1); 
          this.addFrame(2); // Stack temp
          this.variables['c'] = 0; 
          this.addFrame(3); // int c = 0
          
          while(this.mainStack.length > 0) { 
              this.addFrame(4); // while check
              const node = this.mainStack.pop(); 
              if (node) this.tempStack.push(node); 
              this.addFrame(5); // temp.push(s.pop())
              this.variables['c']++; 
              this.addFrame(6); // c++
          }
          this.addFrame(4); // while check (false)
          
          while(this.tempStack.length > 0) { 
              this.addFrame(8); // while check
              const node = this.tempStack.pop(); 
              if(node) this.mainStack.push(node); 
              this.addFrame(9); // s.push(temp.pop())
          }
          this.addFrame(8); // while check (false)

          this.returnValue = this.variables['c']; 
          this.addFrame(10); 
          return this.frames;
        }

        simulateStackRemoveVal(val) {
            this.addFrame(1); 
            this.addFrame(2); // Stack temp
            
            while(this.mainStack.length > 0) { 
                this.addFrame(3); // while check
                const node = this.mainStack.pop(); 
                if(!node) break; 
                this.addFrame(4); // int x = pop
                
                if (node.value === val) { 
                    node.isMatch = true; 
                    this.addFrame(5); // if check (true)
                    node.isDeleted = true;
                    // Void method, do not set returnValue
                    // Skip push
                } else { 
                    this.addFrame(5); // if check (false)
                    this.tempStack.push(node); 
                    this.addFrame(6); // temp.push
                } 
            }
            this.addFrame(3); // while check (false)
            
            while(this.tempStack.length > 0) { 
                this.addFrame(8); // while check
                const node = this.tempStack.pop(); 
                if(node) this.mainStack.push(node); 
                this.addFrame(9); // s.push
            } 
            this.addFrame(8); // while check (false)
            return this.frames;
        }

        simulateStackRemoveLast() {
            this.addFrame(1); 
            this.addFrame(2); // Stack temp

            if (this.mainStack.length === 0) {
                this.addFrame(3); // while check
                this.addFrame(5); // if check
                this.addFrame(7); // while check
                return this.frames;
            }

            while(this.mainStack.length > 0) { 
                this.addFrame(3); // while check
                const node = this.mainStack.pop(); 
                if(node) this.tempStack.push(node); 
                this.addFrame(4); // temp.push
            }
            this.addFrame(3); // while check (false)
            
            this.addFrame(5); // if check
            const bottomNode = this.tempStack.pop(); 
            if (bottomNode) {
                bottomNode.isDeleted = true;
                // Void method, do not set returnValue
                this.addFrame(6); // temp.pop()
            } 
            
            while(this.tempStack.length > 0) { 
                this.addFrame(7); // while check
                const node = this.tempStack.pop(); 
                if (node) this.mainStack.push(node); 
                this.addFrame(8); // s.push
            } 
            this.addFrame(7); // while check (false)
            return this.frames;
        }

        simulateStackRecursiveCount() {
            this.addFrame(1); 
            const s = [{ id: 'root', stage: 0 }]; 
            this.miniMap = { root: { id: 'root', label: 'count', children: [], status: 'active', paramValue: 'Stack', locals: {} }, currentId: 'root' }; 
            const localVars = { 'root': {} }; 
            let idCounter = 0;
            
            while(s.length > 0) {
                const frame = s[s.length - 1]; 
                const vars = localVars[frame.id]; 
                this.miniMap.currentId = frame.id;
                
                if (frame.stage === 0) {
                    this.addFrame(2); // if empty
                    if (this.mainStack.length === 0) { 
                        this.addFrame(3); // return 0
                        this.updateCallStatus(frame.id, 'returned', 0); 
                        vars.retVal = 0; 
                        frame.stage = 2; 
                    } else {
                        const node = this.mainStack.pop(); 
                        if(node) { 
                            node.isDeleted = true; 
                            vars.node = node; 
                        } 
                        this.updateCallLocal(frame.id, 'temp', node ? node.value : '?');
                        this.addFrame(4); // int temp = pop
                        
                        const childId = `c${++idCounter}`; 
                        this.addCallToMap(childId, 'count', frame.id, 'Stack'); 
                        localVars[childId] = {}; 
                        s.push({ id: childId, stage: 0 }); 
                        frame.stage = 1; 
                        this.addFrame(5); // call recursive
                        continue; 
                    }
                } else if (frame.stage === 1) { 
                    const childRet = this.tempReturnValue; 
                    vars.node.isDeleted = false; 
                    this.mainStack.push(vars.node); 
                    this.addFrame(6); // s.push
                    
                    vars.retVal = 1 + childRet; 
                    this.updateCallLocal(frame.id, 'res', vars.retVal);
                    this.updateCallStatus(frame.id, 'returned', vars.retVal); 
                    this.addFrame(7); // return res
                    frame.stage = 2; 
                }
                if (frame.stage === 2) { 
                    this.tempReturnValue = vars.retVal; 
                    if (s.length === 1) { 
                        this.returnValue = vars.retVal; 
                        this.addFrame(7); 
                    } 
                    s.pop(); 
                }
            } 
            return this.frames;
        }

        // --- List Ops ---
        simulateListAddFirst(val) { 
            this.addFrame(1); 
            const newId = uid(); 
            const newNode = { id: newId, value: val, next: null, isNew: true }; 
            this.detachedNodes.push(newNode); // Create outside
            
            this.setPointer('newNode', newId); // Pointer on detached node
            this.addFrame(2); // Node p = new Node
            
            const headId = this.nodes.length > 0 ? this.nodes[0].id : null;
            this.setPointer('lst', headId); 
            newNode.next = headId; 
            this.addFrame(3); // p.setNext(lst) -- animate connection
            
            this.detachedNodes = []; // Remove from detached
            this.nodes.unshift(newNode); // Add to main list
            this.setPointer('head', newId); 
            
            this.returnValue = val; 
            this.setPointer('newNode', null); 
            this.setPointer('lst', null); 
            this.addFrame(4); // return p
            
            delete newNode.isNew; 
            return this.frames; 
        }

        simulateListAddLast(val) { 
            this.addFrame(1); 
            const headId = this.nodes.length > 0 ? this.nodes[0].id : null; 
            this.setPointer('lst', headId); 
            
            // Line 2: if (lst == null)
            if (this.nodes.length === 0) { 
                this.addFrame(2); 
                const newId = uid(); 
                const newNode = { id: newId, value: val, next: null, isNew: true }; 
                this.detachedNodes.push(newNode); // Create outside
                this.setPointer('newNode', newId); 
                
                this.addFrame(3); // return new Node
                
                this.detachedNodes = [];
                this.nodes.push(newNode); // Move to list
                this.returnValue = val; 
                this.setPointer('head', newId); 
                this.setPointer('newNode', null); 
                this.setPointer('lst', null); 
                delete newNode.isNew; 
                return this.frames; 
            } 
            this.addFrame(2); // check failed
            
            this.setPointer('p', headId); 
            this.addFrame(4); // Node p = lst
            
            let i = 0; 
            this.addFrame(5); // while check
            while(i < this.nodes.length - 1) { 
                this.setPointer('p', this.nodes[i].id); 
                
                i++; 
                this.setPointer('p', this.nodes[i].id); 
                this.addFrame(6); // p = p.next
                
                this.addFrame(5); // while check
            } 
            
            const newId = uid(); 
            const newNode = { id: newId, value: val, next: null, isNew: true }; 
            this.detachedNodes.push(newNode); // Create outside
            this.setPointer('newNode', newId); 
            
            this.addFrame(7); // p.setNext (create new node visually)
            
            this.nodes[i].next = newId; // Link visual
            this.detachedNodes = [];
            this.nodes.push(newNode);
            
            this.returnValue = this.nodes[0].value; 
            this.setPointer('p', null); 
            this.setPointer('lst', null); 
            this.setPointer('newNode', null); 
            delete newNode.isNew; 
            
            this.addFrame(8); // return lst
            return this.frames; 
        }

        simulateListFind(val) { 
            this.addFrame(1); 
            const headId = this.nodes.length > 0 ? this.nodes[0].id : null; 
            this.setPointer('lst', headId); 
            this.setPointer('p', headId); 
            this.addFrame(2); // Node p = lst
            
            let found = false; 
            // 3: while(p != null)
            this.addFrame(3);
            for(let i=0; i<this.nodes.length; i++) { 
                this.setPointer('p', this.nodes[i].id); 
                
                this.addFrame(4); // if check
                if (this.nodes[i].value === val) { 
                    this.nodes[i].isMatch = true; 
                    this.addFrame(4); // visual
                    found = true; 
                    this.addFrame(5); // return true
                    break; 
                } 
                
                this.addFrame(6); // p = p.next
                this.addFrame(3); // while check
            } 
            
            if (!found) { 
                this.setPointer('p', null); 
                this.addFrame(3); // Final while check (failed)
                this.returnValue = "false"; 
                this.addFrame(8); // return false
            } else {
                this.returnValue = "true";
            }
            return this.frames; 
        }

        simulateListDelete(val) { 
            this.addFrame(1); 
            
            // 2: if (lst == null)
            if(this.nodes.length===0) {
                this.addFrame(2);
                this.addFrame(3); // return null
                return this.frames; 
            }
            this.addFrame(2); // check false
            
            // 4: if (lst.val == target)
            if(this.nodes[0].value === val) { 
                this.addFrame(4);
                this.nodes.shift(); 
                this.addFrame(5); // return next
                return this.frames; 
            }
            this.addFrame(4); // check false

            this.setPointer('prev', this.nodes[0].id); 
            this.addFrame(6); // Node prev = lst
            
            this.addFrame(7); // while check
            for(let i=0; i<this.nodes.length-1; i++) { 
                this.setPointer('prev', this.nodes[i].id); 
                
                this.addFrame(8); // if (prev.next.val == target)
                if(this.nodes[i+1].value === val) { 
                    this.nodes[i+1].isMatch = true; 
                    this.addFrame(8); 
                    this.nodes.splice(i+1, 1); 
                    this.nodes[i].next = this.nodes[i+1]?.id || null; 
                    
                    this.addFrame(9); // prev.setNext
                    this.setPointer('prev', null); 
                    this.addFrame(10); // return lst
                    return this.frames; 
                } 
                
                this.addFrame(12); // prev = prev.next
                this.addFrame(7); // while check
            } 
            this.setPointer('prev', null); 
            this.addFrame(7); // while check (false)
            this.addFrame(14); // return lst
            return this.frames; 
        }

        simulateListCount() { 
            this.addFrame(1); 
            this.variables['c'] = 0; 
            this.addFrame(2); // int c = 0
            
            const headId = this.nodes.length > 0 ? this.nodes[0].id : null; 
            this.setPointer('p', headId); 
            this.addFrame(3); // for loop init/check
            
            for(let i=0; i<this.nodes.length; i++) { 
                this.setPointer('p', this.nodes[i].id); 
                this.variables['c']++; 
                this.addFrame(4); // c++
                this.addFrame(3); // loop update/check
            } 
            this.setPointer('p', null); 
            this.addFrame(3); // loop check (false)
            
            this.returnValue = this.variables['c']; 
            this.addFrame(5); // return c
            return this.frames; 
        }

        simulateListRecursiveCount() { 
            this.addFrame(1); 
            const s = [{ id: 'root', stage: 0, nodeIndex: 0 }]; 
            const firstVal = this.nodes.length > 0 ? this.nodes[0].value : 'null'; 
            this.miniMap = { root: { id: 'root', label: 'count', children: [], status: 'active', paramValue: firstVal, locals: {} }, currentId: 'root' }; 
            const localVars = { 'root': {} }; 
            let idCounter = 0; 
            
            while(s.length > 0) { 
                const frame = s[s.length - 1]; 
                const vars = localVars[frame.id]; 
                this.miniMap.currentId = frame.id; 
                
                if (frame.stage === 0) { 
                    const currNode = this.nodes[frame.nodeIndex]; 
                    if (currNode) this.setPointer('p', currNode.id); else this.setPointer('p', null); 
                    
                    this.addFrame(2); // if (p == null)
                    if (frame.nodeIndex >= this.nodes.length) { 
                        this.addFrame(3); // return 0
                        vars.retVal = 0; 
                        this.updateCallStatus(frame.id, 'returned', 0); 
                        frame.stage = 2; 
                    } else { 
                        const childId = `c${++idCounter}`; 
                        const nextVal = this.nodes[frame.nodeIndex+1] ? this.nodes[frame.nodeIndex+1].value : 'null'; 
                        this.addCallToMap(childId, 'count', frame.id, nextVal); 
                        localVars[childId] = {}; 
                        s.push({ id: childId, stage: 0, nodeIndex: frame.nodeIndex + 1 }); 
                        frame.stage = 1; 
                        this.addFrame(4); // return 1 + recursive
                        continue; 
                    } 
                } else if (frame.stage === 1) { 
                    const childRet = this.tempReturnValue; 
                    this.setPointer('p', this.nodes[frame.nodeIndex].id); 
                    vars.retVal = 1 + childRet; 
                    this.updateCallStatus(frame.id, 'returned', vars.retVal); 
                    this.addFrame(4); // result calc
                    frame.stage = 2; 
                } 
                if (frame.stage === 2) { 
                    this.tempReturnValue = vars.retVal; 
                    if (s.length === 1) { 
                        this.returnValue = vars.retVal; 
                        this.addFrame(4); 
                    } 
                    s.pop(); 
                } 
            } 
            return this.frames; 
        }

        simulateListAddAfter(target, val) { 
            this.addFrame(1); 
            const headId = this.nodes.length > 0 ? this.nodes[0].id : null; 
            this.setPointer('lst', headId); 
            this.setPointer('p', headId); 
            this.addFrame(2); // Node p = lst
            
            let i = 0; 
            this.addFrame(3); // while check
            while(i < this.nodes.length) { 
                this.setPointer('p', this.nodes[i].id); 
                
                this.addFrame(4); // if (p.val == target)
                if(this.nodes[i].value === target) { 
                    this.nodes[i].isMatch = true; 
                    this.addFrame(4); 
                    
                    const newId = uid(); 
                    const n = {id: newId, value: val, next: null, isNew: true}; 
                    this.detachedNodes.push(n); // Create outside
                    this.setPointer('newNode', newId); 
                    this.addFrame(5); // Node temp = new
                    
                    if(this.nodes[i+2]) n.next = this.nodes[i+2].id; // Visual logic for "setting next" (in memory)
                    this.addFrame(6); // temp.setNext
                    
                    this.detachedNodes = [];
                    this.nodes.splice(i+1, 0, n); // Move to list
                    this.nodes[i].next = newId; 
                    this.addFrame(7); // p.setNext
                    
                    this.setPointer('newNode', null); 
                    this.setPointer('p', null); 
                    delete n.isNew; 
                    this.addFrame(8); // return
                    return this.frames; 
                } 
                
                i++; 
                this.addFrame(10); // p = p.next
                this.addFrame(3); // while check
            } 
            this.setPointer('p', null); 
            this.addFrame(3); // while check (false)
            return this.frames; 
        }

        simulateListAddBefore(target, val) { 
            this.addFrame(1); 
            const headId = this.nodes.length > 0 ? this.nodes[0].id : null; 
            this.setPointer('lst', headId); 
            
            // 2: if (lst == null)
            if(this.nodes.length === 0) { 
                this.addFrame(2); 
                this.addFrame(3); // return null
                return this.frames; 
            } 
            this.addFrame(2); // check false
            
            // 4: if (lst.val == target)
            if(this.nodes[0].value === target) { 
                this.nodes[0].isMatch = true; 
                this.addFrame(4); 
                
                const newId = uid(); 
                const n = {id: newId, value: val, next: null, isNew: true}; 
                this.detachedNodes.push(n); // Create outside
                this.setPointer('newNode', newId); 
                this.addFrame(5); // Node p = new
                
                n.next = this.nodes[0].id;
                this.addFrame(6); // p.setNext(lst)
                
                this.detachedNodes = [];
                this.nodes.unshift(n);
                this.setPointer('head', newId); 
                delete n.isNew; 
                this.addFrame(7); // return p
                return this.frames; 
            } 
            this.addFrame(4); // check false

            this.setPointer('prev', headId); 
            this.addFrame(9); // Node prev = lst
            
            let i = 0; 
            this.addFrame(10); // while check
            while(i < this.nodes.length - 1) { 
                this.setPointer('prev', this.nodes[i].id); 
                
                this.addFrame(11); // if (prev.next.val == target)
                if(this.nodes[i+1].value === target) { 
                    this.nodes[i+1].isMatch = true; 
                    this.addFrame(11); 
                    
                    const newId = uid(); 
                    const n = {id: newId, value: val, next: null, isNew: true}; 
                    this.detachedNodes.push(n); // Create outside
                    this.setPointer('newNode', newId); 
                    this.addFrame(12); // Node temp = new
                    
                    n.next = this.nodes[i+1].id;
                    this.addFrame(13); // temp.setNext
                    
                    this.detachedNodes = [];
                    this.nodes.splice(i+1, 0, n);
                    this.nodes[i].next = newId; 
                    this.addFrame(14); // prev.setNext
                    
                    this.setPointer('prev', null); 
                    this.setPointer('newNode', null); 
                    delete n.isNew; 
                    this.addFrame(15); // return lst
                    return this.frames; 
                } 
                
                i++; 
                this.addFrame(17); // prev = prev.next
                this.addFrame(10); // while check
            } 
            this.setPointer('prev', null); 
            this.addFrame(10); // while check (false)
            this.addFrame(19); // return lst
            return this.frames; 
        }

        // --- Queue Ops ---
        simulateQueueCount() {
            this.addFrame(1); 
            this.addFrame(2); // int c = 0
            this.variables['c'] = 0;
            this.addFrame(3); // Queue temp
            
            const q = [...this.nodes]; 
            const len = q.length; 
            
            this.addFrame(4); // while check
            for(let i=0; i<len; i++) { 
                const n = this.nodes.shift(); 
                if(n) { n.isTemp = true; this.nodes.push(n); } 
                this.addFrame(5); // temp.insert(remove)
                this.variables['c']++; 
                this.addFrame(6); // c++
                this.addFrame(4); // while check
            }
            
            this.addFrame(8); // while check 2
            for(let i=0; i<len; i++) { 
                const n = this.nodes.shift(); 
                if(n) { n.isTemp = false; this.nodes.push(n); } 
                this.addFrame(9); // q.insert(remove)
                this.addFrame(8); // while check 2
            }
            
            this.returnValue = this.variables['c']; 
            this.addFrame(10); // return c
            return this.frames;
        }
        
        simulateQueueInsert(val) { this.addFrame(1); this.nodes.push({ id: uid(), value: val, next: null }); this.addFrame(2); return this.frames; }
        simulateQueueRemove() { this.addFrame(1); if(this.nodes.length > 0) { const v = this.nodes.shift(); if(v) this.returnValue = v.value; } this.addFrame(2); return this.frames; }
        
        simulateQueueRemoveVal(val) {
            this.addFrame(1);
            this.addFrame(2); // temp
            
            const originalLen = this.nodes.length;
            this.addFrame(3); // while check
            for (let i = 0; i < originalLen; i++) {
              const node = this.nodes.shift();
              if (!node) break;
              
              this.addFrame(4); // x = remove
              
              if (node.value === val) {
                node.isMatch = true;
                this.addFrame(5); // if check (true)
                // Removed setting return value for void method
                // skip insert
              } else {
                this.addFrame(5); // if check (false)
                node.isTemp = true;
                this.nodes.push(node);
                this.addFrame(6); // insert
              }
              this.addFrame(3); // while check
            }
            
            this.addFrame(8); // while check 2
            const tempLen = this.nodes.length;
            for (let i = 0; i < tempLen; i++) {
               const node = this.nodes.shift();
               if (node) {
                   node.isTemp = false;
                   this.nodes.push(node);
                   this.addFrame(9); // insert
               }
               this.addFrame(8); // while check 2
            }
            return this.frames;
        }
        
        simulateQueueRemoveLast() { 
            this.addFrame(1); 
            this.addFrame(2); // Queue temp
            
            const initialSize = this.nodes.length;
            
            // Loop 1: Move all to temp
            this.addFrame(3); // while(!q.isEmpty())
            for(let i=0; i<initialSize; i++) {
                const n = this.nodes.shift();
                if (n) {
                   n.isTemp = true;
                   this.nodes.push(n);
                }
                this.addFrame(4); // temp.insert(q.remove())
                this.addFrame(3); // while check
            }
            
            // Loop 2: Move back to q except last
            this.addFrame(5); // while(!temp.isEmpty())
            for(let i=0; i<initialSize; i++) {
                // Visual remove from temp queue
                const n = this.nodes.shift();
                this.addFrame(6); // int x = temp.remove()
                
                this.addFrame(7); // if(!temp.isEmpty())
                
                if (i < initialSize - 1) {
                    // Not last
                    if (n) {
                        n.isTemp = false;
                        this.nodes.push(n);
                    }
                    this.addFrame(8); // q.insert(x)
                }
                this.addFrame(5); // while check
            }
            
            return this.frames; 
        }
        
        simulateQueueRecursiveCount() {
             this.addFrame(1); 
             const s = [{ id: 'root', stage: 0 }]; 
             this.miniMap = { root: { id: 'root', label: 'count', children: [], status: 'active', paramValue: 'Queue', locals: {} }, currentId: 'root' }; 
             const localVars = { 'root': {} }; 
             let idCounter = 0;
             
             while(s.length > 0) {
                 const frame = s[s.length - 1]; 
                 const vars = localVars[frame.id]; 
                 this.miniMap.currentId = frame.id;
                 
                 if(frame.stage === 0) {
                     this.addFrame(2); // if empty
                     if (this.nodes.length === 0) { 
                         this.addFrame(3); // return 0
                         vars.retVal = 0; 
                         this.updateCallStatus(frame.id, 'returned', 0); 
                         frame.stage = 2; 
                     } else {
                         const node = this.nodes.shift(); 
                         if(node) { node.isDeleted = true; vars.node = node; } 
                         this.updateCallLocal(frame.id, 'temp', node ? node.value : '?');
                         this.addFrame(4); // int temp = remove
                         
                         const childId = `c${++idCounter}`; 
                         this.addCallToMap(childId, 'count', frame.id, 'Queue'); 
                         localVars[childId] = {}; 
                         s.push({id: childId, stage: 0}); 
                         frame.stage = 1; 
                         this.addFrame(5); // call recursive
                         continue;
                     }
                 } else if (frame.stage === 1) { 
                     const childRet = this.tempReturnValue; 
                     const node = vars.node; 
                     node.isDeleted = false; 
                     this.nodes.push(node); 
                     this.addFrame(6); // insert
                     
                     vars.retVal = 1 + childRet; 
                     this.updateCallLocal(frame.id, 'res', vars.retVal);
                     this.updateCallStatus(frame.id, 'returned', vars.retVal); 
                     this.addFrame(7); // return
                     frame.stage = 2; 
                 }
                 if (frame.stage === 2) { 
                     this.tempReturnValue = vars.retVal; 
                     if (s.length === 1) { 
                         this.returnValue = vars.retVal; 
                         this.addFrame(7); 
                     } 
                     s.pop(); 
                 }
             } 
             return this.frames;
        }
      }

      // ==========================================
      // COMPONENTS
      // ==========================================
      const Pointer = ({ label, color }) => (
        <motion.div layoutId={`pointer-${label}`} initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0 }} className="absolute -top-10 left-1/2 -translate-x-1/2 flex flex-col items-center z-50 pointer-events-none">
          <div className={`px-2 py-0.5 rounded text-[10px] font-bold shadow-sm mb-0.5 whitespace-nowrap ${color}`}>{label}</div>
          <ArrowDownToLine className="w-4 h-4 text-slate-500" />
        </motion.div>
      );

      const ResultOverlay = ({ returnValue, onDismiss }) => (
          <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -20 }} className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-50 bg-white border-2 border-emerald-500 shadow-2xl rounded-xl p-6 flex flex-col items-center gap-2 pointer-events-auto">
              <div className="text-xs font-bold text-slate-400 uppercase tracking-widest">Return Value</div>
              <div className="text-3xl font-bold text-emerald-600 font-mono">{String(returnValue)}</div>
              <button onClick={onDismiss} className="mt-2 text-xs text-slate-400 hover:text-slate-600 underline">Close</button>
          </motion.div>
      );

      const VariablesDisplay = ({ variables }) => (
        <div className="absolute top-16 right-4 z-30 flex flex-col gap-2 pointer-events-none">
          <AnimatePresence>
            {Object.entries(variables).map(([k, v]) => (
              <motion.div 
                key={k} 
                initial={{ opacity: 0, x: 20 }} 
                animate={{ opacity: 1, x: 0 }} 
                exit={{ opacity: 0, x: 20 }} 
                className="bg-white/90 backdrop-blur p-2 rounded shadow border border-slate-200 flex items-center gap-2 font-mono text-xs pointer-events-auto"
              >
                <div className="bg-slate-100 p-1 rounded text-slate-500"><Hash className="w-3 h-3"/></div>
                <span className="font-bold text-slate-600">{k}:</span>
                <span className="font-bold text-indigo-600">{String(v)}</span>
              </motion.div>
            ))}
          </AnimatePresence>
        </div>
      );

      const MiniNodeIcon = ({ value }) => <div className="inline-flex items-center justify-center w-5 h-5 rounded-full border border-slate-300 bg-white text-[8px] font-bold text-slate-600 shadow-sm ml-1">{value === 'null' ? '∅' : value}</div>;

      const MiniMap = ({ mapData }) => {
          const [zoom, setZoom] = useState(1);
          const [minimized, setMinimized] = useState(false);

          if (!mapData || !mapData.root) return null;

          const renderNode = (node) => (
              <div key={node.id} className="flex flex-col items-center mx-1">
                  <div className={`border rounded px-2 py-1 text-[10px] font-mono mb-1 transition-all flex flex-col items-center gap-1 whitespace-nowrap ${mapData.currentId === node.id ? 'bg-yellow-100 border-yellow-400 shadow-md ring-1 ring-yellow-300' : 'bg-white border-slate-200'} ${node.status === 'returned' ? 'bg-emerald-50 border-emerald-300' : ''}`}>
                      <div className="flex items-center gap-1">
                          <span className="font-bold text-slate-600">{node.label}</span>
                          <span className="text-slate-400">(</span><MiniNodeIcon value={node.paramValue} /><span className="text-slate-400">)</span>
                          {node.value !== null && <span className="text-emerald-600 font-bold ml-1">→ {node.value}</span>}
                      </div>
                      {node.locals && Object.keys(node.locals).length > 0 && (
                          <div className="w-full pt-1 mt-0.5 border-t border-slate-200/50 flex flex-wrap gap-x-2 gap-y-0.5 text-[9px] text-slate-500">
                              {Object.entries(node.locals).map(([k, v]) => (
                                  <span key={k} className="flex gap-1"><span>{k}:</span><span className="font-bold text-blue-600">{String(v)}</span></span>
                              ))}
                          </div>
                      )}
                  </div>
                  {node.children.length > 0 && <div className="flex gap-2 relative mt-1 border-t border-slate-200 pt-1">{node.children.map(child => <div key={child.id} className="flex flex-col items-center">{renderNode(child)}</div>)}</div>}
              </div>
          );

          if (minimized) {
              return (
                  <div className="bg-white border border-slate-300 shadow-md rounded-lg p-2 absolute bottom-4 right-4 z-40 cursor-pointer hover:bg-slate-50" onClick={() => setMinimized(false)}>
                      <Maximize2 className="w-4 h-4 text-slate-500" />
                  </div>
              );
          }

          return (
              <div className="bg-white/95 backdrop-blur border border-slate-300 shadow-2xl rounded-lg flex flex-col overflow-hidden max-h-[300px] max-w-[400px] z-40">
                  <div className="flex-none p-2 border-b border-slate-100 flex justify-between items-center bg-slate-50">
                      <div className="text-[10px] font-bold text-slate-500 uppercase tracking-widest flex items-center gap-1"><Network className="w-3 h-3" /> Call Stack</div>
                      <div className="flex items-center gap-1">
                          <button onClick={() => setZoom(z => Math.max(0.5, z - 0.1))} className="p-1 hover:bg-slate-200 rounded text-slate-500"><ZoomOut className="w-3 h-3" /></button>
                          <span className="text-[9px] w-6 text-center text-slate-400">{Math.round(zoom * 100)}%</span>
                          <button onClick={() => setZoom(z => Math.min(2, z + 0.1))} className="p-1 hover:bg-slate-200 rounded text-slate-500"><ZoomIn className="w-3 h-3" /></button>
                          <div className="w-px h-3 bg-slate-300 mx-1"></div>
                          <button onClick={() => setMinimized(true)} className="p-1 hover:bg-slate-200 rounded text-slate-500"><Minimize2 className="w-3 h-3" /></button>
                      </div>
                  </div>
                  <div className="flex-1 overflow-auto p-4 min-w-[250px]">
                      <div style={{ transform: `scale(${zoom})`, transformOrigin: 'top center', width: 'fit-content', margin: '0 auto' }}>
                          {renderNode(mapData.root)}
                      </div>
                  </div>
              </div>
          );
      };

      const NodeComponent = ({ 
          node, 
          index, 
          pointers, 
          isList, 
          showNext = true, 
          isVertical = false, 
          arrowDirection = 'right', 
          hideNull = false,
          hasNext,
          showExit = false
      }) => {
        const myPointers = Object.entries(pointers).filter(([_, id]) => id === node.id).map(([name, _]) => ({ name, color: COLORS[name] || COLORS.default }));
        const showArrow = hasNext !== undefined ? hasNext : !!node.next;

        return (
          <div className={`flex ${isVertical ? 'flex-col' : 'flex-row'} items-center transform transition-all duration-300`}>
            {isList === false && !isVertical && arrowDirection === 'left' && (
                <div className={`w-8 flex items-center justify-center text-slate-300 ${showExit ? '' : 'opacity-0'}`}>
                    <ArrowLeft className="w-5 h-5" />
                </div>
            )}
            
            <motion.div layout initial={{ scale: 0.8, opacity: 0 }} animate={{ scale: node.isMatch ? 1.1 : 1, opacity: node.isDeleted ? 0 : 1, backgroundColor: node.isNew ? '#dcfce7' : (node.isMatch ? '#bbf7d0' : (node.isTemp ? '#e2e8f0' : 'white')), borderColor: node.isMatch ? '#22c55e' : (node.isTemp ? '#94a3b8' : '#cbd5e1') }} className={`relative flex flex-col border-2 rounded-lg shadow-md w-20 h-14 shrink-0 transition-colors duration-300 z-10`}>
              <div className="absolute w-full h-full pointer-events-none"><AnimatePresence>{myPointers.map((p, i) => (<div key={p.name} style={{ position: 'absolute', top: -10, left: 0, width: '100%', transform: `translateY(-${(i+1)*30}px)` }}><Pointer key={p.name} label={p.name} color={p.color} /></div>))}</AnimatePresence></div>
              <div className="flex-1 flex items-center justify-center font-mono text-lg font-bold border-b border-inherit">{node.value}</div>
              {showNext && <div className="h-4 bg-slate-50/50 text-[8px] text-slate-400 flex items-center justify-center uppercase tracking-widest">Next</div>}
            </motion.div>
            
            {showNext && !isVertical && (
                <div className="w-8 flex items-center justify-center text-slate-300">
                  {showArrow ? (
                      arrowDirection === 'left' ? <ArrowLeft className="w-5 h-5" /> : <ArrowRight className="w-5 h-5" />
                  ) : (
                      !hideNull && <div className="w-2 h-2 rounded-full bg-red-300" title="Null" />
                  )}
                </div>
            )}
          </div>
        );
      };

      // ==========================================
      // MAIN APP
      // ==========================================
      class ErrorBoundary extends React.Component {
        constructor(props) {
            super(props);
            this.state = { hasError: false, error: null };
        }
        static getDerivedStateFromError(error) { return { hasError: true, error }; }
        componentDidCatch(error, errorInfo) { console.error("App Crash:", error, errorInfo); }
        render() {
          if (this.state.hasError) {
            return (
              <div className="p-8 text-red-600 bg-red-50 h-screen flex flex-col items-center justify-center font-mono">
                <h1 className="text-2xl font-bold mb-4">Application Crashed</h1>
                <pre className="bg-white p-4 rounded border border-red-200 max-w-2xl overflow-auto">{this.state.error?.toString()}</pre>
                <button onClick={() => window.location.reload()} className="mt-4 px-4 py-2 bg-red-600 text-white rounded">Reload Page</button>
              </div>
            );
          }
          return this.props.children;
        }
      }

      function WrappedApp() {
          return <ErrorBoundary><DataStructureVisualizer /></ErrorBoundary>;
      }

      function DataStructureVisualizer() {
        const [activeDS, setActiveDS] = useState(DATA_STRUCTURES.LINKED_LIST);
        const [nodes, setNodes] = useState(generateInitialList());
        const [detachedNodes, setDetachedNodes] = useState([]);
        const [pointers, setPointers] = useState({});
        const [variables, setVariables] = useState({});
        const [miniMap, setMiniMap] = useState(null);
        const [returnValue, setReturnValue] = useState(null);
        const [frames, setFrames] = useState([]);
        const [currentFrameIndex, setCurrentFrameIndex] = useState(-1);
        const [isPlaying, setIsPlaying] = useState(false);
        const [playbackSpeed, setPlaybackSpeed] = useState(1000);
        const [lang, setLang] = useState('java');
        const [inputVal, setInputVal] = useState('');
        const [inputTarget, setInputTarget] = useState('');
        const [statusMsg, setStatusMsg] = useState('Ready');
        const [selectedMethod, setSelectedMethod] = useState('');
        const [activeOp, setActiveOp] = useState(null);

        useEffect(() => { 
            const ops = OPS_CONFIG[activeDS];
            if (ops && ops.length > 0) setSelectedMethod(ops[0].value); 
            setReturnValue(null); 
            handleClear();
        }, [activeDS]);

        useEffect(() => { 
            let timer; 
            if (isPlaying && currentFrameIndex < frames.length - 1) 
                timer = setTimeout(() => setCurrentFrameIndex(prev => prev + 1), playbackSpeed); 
            else if (currentFrameIndex >= frames.length - 1) 
                setIsPlaying(false); 
            return () => clearTimeout(timer); 
        }, [isPlaying, currentFrameIndex, frames, playbackSpeed]);

        useEffect(() => { 
            if (currentFrameIndex >= 0 && frames[currentFrameIndex]) { 
                const f = frames[currentFrameIndex]; 
                setNodes(f.nodes); 
                setDetachedNodes(f.detachedNodes || []);
                setPointers(f.pointers); 
                setVariables(f.variables||{}); 
                setMiniMap(f.miniMap||null); 
                setStatusMsg(f.message||'Executing...'); 
                if (f.returnValue !== null && f.returnValue !== undefined) { 
                    setReturnValue(f.returnValue); 
                    setIsPlaying(false); 
                } 
            } 
        }, [currentFrameIndex, frames]);

        const handleGenerate = () => { 
            // Disable generation for Binary Tree
            if (activeDS === DATA_STRUCTURES.BINARY_TREE) return;

            setFrames([]); 
            setIsPlaying(false); 
            setVariables({}); 
            setMiniMap(null); 
            setReturnValue(null); 
            setPointers({}); 
            setDetachedNodes([]);
            setNodes(generateRandomList(5)); 
        };
        
        const handleClear = () => { setNodes([]); setDetachedNodes([]); setPointers({}); setFrames([]); setIsPlaying(false); setReturnValue(null); setMiniMap(null); };

        const runOperation = () => {
          // Disable operations for Binary Tree
          if (activeDS === DATA_STRUCTURES.BINARY_TREE) return;
          if (!selectedMethod) return; 
          
          setIsPlaying(false); setFrames([]); setReturnValue(null); setVariables({}); setMiniMap(null); setPointers({});
          const cleanNodes = nodes.map(n => ({...n, isMatch: false, isNew: false, isDeleted: false, isTemp: false})); 
          setNodes(cleanNodes);
          setDetachedNodes([]);
          
          const builder = new SnapshotBuilder(cleanNodes, activeDS);
          let generatedFrames = [];
          const val = parseInt(inputVal) || 0; 
          const target = parseInt(inputTarget) || 0;

          if (activeDS === DATA_STRUCTURES.LINKED_LIST) {
              if (selectedMethod === 'addFirst') generatedFrames = builder.simulateListAddFirst(val);
              else if (selectedMethod === 'addLast') generatedFrames = builder.simulateListAddLast(val);
              else if (selectedMethod === 'find') generatedFrames = builder.simulateListFind(target);
              else if (selectedMethod === 'count') generatedFrames = builder.simulateListCount();
              else if (selectedMethod === 'delete') generatedFrames = builder.simulateListDelete(target);
              else if (selectedMethod === 'addAfter') generatedFrames = builder.simulateListAddAfter(target, val);
              else if (selectedMethod === 'addBefore') generatedFrames = builder.simulateListAddBefore(target, val);
              else if (selectedMethod === 'recursiveCount') generatedFrames = builder.simulateListRecursiveCount();
          } else if (activeDS === DATA_STRUCTURES.STACK) {
              if (selectedMethod === 'push') generatedFrames = builder.simulateStackPush(val);
              else if (selectedMethod === 'pop') generatedFrames = builder.simulateStackPop();
              else if (selectedMethod === 'count') generatedFrames = builder.simulateStackCount();
              else if (selectedMethod === 'removeVal') generatedFrames = builder.simulateStackRemoveVal(target);
              else if (selectedMethod === 'removeLast') generatedFrames = builder.simulateStackRemoveLast();
              else if (selectedMethod === 'recursiveCount') generatedFrames = builder.simulateStackRecursiveCount();
          } else if (activeDS === DATA_STRUCTURES.QUEUE) {
              if (selectedMethod === 'insert') generatedFrames = builder.simulateQueueInsert(val);
              else if (selectedMethod === 'remove') generatedFrames = builder.simulateQueueRemove();
              else if (selectedMethod === 'count') generatedFrames = builder.simulateQueueCount();
              else if (selectedMethod === 'removeVal') generatedFrames = builder.simulateQueueRemoveVal(target);
              else if (selectedMethod === 'removeLast') generatedFrames = builder.simulateQueueRemoveLast();
              else if (selectedMethod === 'recursiveCount') generatedFrames = builder.simulateQueueRecursiveCount();
          } 

          if (generatedFrames.length > 0) { 
              setFrames(generatedFrames); 
              setCurrentFrameIndex(0); 
              setIsPlaying(true); 
              setActiveOp(selectedMethod); 
              setInputVal(''); 
              setInputTarget(''); 
          }
        };
        
        const currentOpConfig = OPS_CONFIG[activeDS]?.find(op => op.value === selectedMethod);
        const showValInput = currentOpConfig?.params.includes('val');
        const showTargetInput = currentOpConfig?.params.includes('target');
        const safeCodeSnippet = CODE_SNIPPETS[activeDS]?.[selectedMethod]?.[lang] || "// Code unavailable";

        const renderVisuals = () => {
            // Binary Tree - Under Construction View
            if (activeDS === DATA_STRUCTURES.BINARY_TREE) {
                return (
                    <div className="flex flex-col items-center justify-center h-full w-full bg-slate-50/50">
                         <div className="bg-white p-8 rounded-2xl shadow-xl flex flex-col items-center gap-4 border border-slate-200">
                             <div className="p-4 bg-orange-100 rounded-full text-orange-600">
                                 <Construction className="w-12 h-12" />
                             </div>
                             <h2 className="text-2xl font-bold text-slate-700">תחת בנייה</h2>
                             <p className="text-slate-500 text-sm">הסימולציה עבור עץ בינארי עדיין בפיתוח</p>
                         </div>
                    </div>
                )
            }

            if (activeDS === DATA_STRUCTURES.QUEUE) {
                const mainQ = nodes.filter(n => !n.isTemp); const tempQ = nodes.filter(n => n.isTemp);
                return (
                    <div className="flex-1 flex flex-col items-center justify-center gap-8 px-4 h-full relative">
                        <AnimatePresence>{returnValue !== null && <ResultOverlay returnValue={returnValue} onDismiss={() => setReturnValue(null)} />}</AnimatePresence>
                        <VariablesDisplay variables={variables} />
                        
                        {/* Queue Container */}
                        <div className="w-full max-w-4xl flex flex-col gap-1 overflow-hidden mt-20">
                          <div className="flex justify-between px-2 text-xs font-bold text-slate-400 uppercase tracking-widest">
                             <span>Exit / Head</span>
                             <span>Entry</span>
                          </div>
                          <div className="relative p-4 pt-24 bg-slate-100 rounded-lg w-full flex items-center gap-2 overflow-x-auto min-h-[160px]">
                              <AnimatePresence mode='popLayout'>
                                  {mainQ.map((node, i) => (
                                    <NodeComponent 
                                      key={node.id} 
                                      node={node} 
                                      index={i} 
                                      pointers={i === 0 ? { ...pointers, head: node.id } : {}} 
                                      showNext={true} 
                                      isList={false} 
                                      arrowDirection="left"
                                      hideNull={true}
                                      hasNext={i < mainQ.length - 1}
                                      showExit={i === 0}
                                    />
                                  ))}
                              </AnimatePresence>
                          </div>
                        </div>

                        {tempQ.length > 0 && (
                            <div className="w-full max-w-4xl flex flex-col gap-1">
                                <div className="text-xs font-bold text-slate-400 uppercase tracking-widest px-2">Temp Queue</div>
                                <div className="relative p-4 pt-12 border-2 border-dashed border-slate-300 bg-slate-50 rounded-lg w-full flex items-center gap-2 overflow-x-auto min-h-[120px]">
                                  <AnimatePresence mode='popLayout'>
                                      {tempQ.map((node, i) => (
                                          <NodeComponent 
                                              key={node.id} 
                                              node={node} 
                                              index={i} 
                                              pointers={{}} 
                                              showNext={true} 
                                              isList={false}
                                              arrowDirection="left" 
                                              hideNull={true}
                                              hasNext={i < tempQ.length - 1}
                                          />
                                      ))}
                                  </AnimatePresence>
                                </div>
                            </div>
                        )}
                        {miniMap && <div className="absolute bottom-8 right-8"><MiniMap mapData={miniMap} /></div>}
                    </div>
                )
            }
            if (activeDS === DATA_STRUCTURES.STACK) {
                const mainStackNodes = nodes.filter(n => !n.isTemp); const tempStackNodes = nodes.filter(n => n.isTemp);
                return (
                    <div className="flex-1 flex flex-row items-end justify-center gap-8 pb-8 px-4 h-full relative">
                         <AnimatePresence>{returnValue !== null && <ResultOverlay returnValue={returnValue} onDismiss={() => setReturnValue(null)} />}</AnimatePresence>
                         <VariablesDisplay variables={variables} />
                         <div className="flex flex-col items-center justify-end w-32 h-full">
                             <AnimatePresence mode='popLayout'>
                                 <div className="flex flex-col-reverse items-center w-full border-l-4 border-r-4 border-b-4 border-slate-300 bg-slate-100 rounded-b-xl p-2 min-h-[200px]">
                                      {mainStackNodes.map((node, i) => <NodeComponent key={node.id} node={node} index={i} pointers={i === mainStackNodes.length - 1 ? { ...pointers, top: node.id } : {}} showNext={false} isVertical={true} />)}
                                 </div>
                             </AnimatePresence>
                             <span className="font-bold text-slate-400 text-sm mt-2">STACK</span>
                         </div>
                         {tempStackNodes.length > 0 && <div className="flex flex-col items-center justify-end w-32 h-full"><div className="flex flex-col-reverse items-center w-full border-2 border-dashed border-slate-300 bg-slate-50 rounded-xl p-2 min-h-[200px]"><AnimatePresence mode='popLayout'>{tempStackNodes.map((node, i) => <NodeComponent key={node.id} node={node} index={i} pointers={{}} showNext={false} isVertical={true} />)}</AnimatePresence></div><span className="font-bold text-slate-400 text-sm mt-2">TEMP</span></div>}
                         {miniMap && <div className="absolute bottom-8 right-8"><MiniMap mapData={miniMap} /></div>}
                    </div>
                );
            }
            return (
                <div className="flex flex-row h-full w-full">
                    <div className="flex-1 p-8 pt-40 overflow-auto relative">
                        <AnimatePresence>{returnValue !== null && <ResultOverlay returnValue={returnValue} onDismiss={() => setReturnValue(null)} />}</AnimatePresence>
                        <VariablesDisplay variables={variables} />
                        
                        <AnimatePresence>
                            {detachedNodes.map((node, i) => (
                                <motion.div 
                                  key={node.id}
                                  initial={{ opacity: 0, y: -50 }}
                                  animate={{ opacity: 1, y: 0 }}
                                  exit={{ opacity: 0, scale: 0.5 }}
                                  className="absolute z-20"
                                  style={{ top: '60px', left: `${100 + i * 120}px` }}
                                >
                                   <div className="text-xs font-bold text-slate-400 mb-1 text-center uppercase tracking-wider">New</div>
                                   <NodeComponent node={node} index={i} pointers={pointers} showNext={true} />
                                </motion.div>
                            ))}
                        </AnimatePresence>

                        <div className="flex flex-wrap items-start content-start gap-y-32">
                            <AnimatePresence mode='popLayout'>
                                {nodes.map((node, i) => <NodeComponent key={node.id} node={node} index={i} pointers={pointers} showNext={true} />)}
                            </AnimatePresence>
                            {nodes.length === 0 && <div className="text-slate-400 w-full text-center mt-20">Empty List (Head is Null)</div>}
                        </div>
                    </div>
                    {miniMap && <div className="absolute bottom-8 right-8"><MiniMap mapData={miniMap} /></div>}
                </div>
            );
        };

        return (
          <div className="h-screen w-full bg-slate-50 flex flex-col font-sans overflow-hidden" dir="ltr">
            <header className="flex-none bg-white border-b border-slate-200 p-4 flex justify-between items-center shadow-sm z-50" dir="rtl">
               <div className="flex flex-col justify-center">
                  <div className="flex items-center gap-2">
                      <Layers className="text-indigo-600 w-6 h-6" />
                      <h1 className="font-bold text-lg text-slate-800">סימולטור מבנה נתונים לפי מחלקות בגרות</h1>
                  </div>
                  <span className="text-[11px] text-slate-500 font-medium">נוצר על ידי טל סימון רכז הנדסת תוכנה מטרווסט רעננה</span>
               </div>
               
               <div className="flex gap-2" dir="ltr">{Object.values(DATA_STRUCTURES).map(ds => <button key={ds} onClick={() => setActiveDS(ds)} className={`px-3 py-1.5 text-xs font-bold rounded-lg transition-colors ${activeDS === ds ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}`}>{ds}</button>)}</div>
               <div className="flex gap-1 bg-slate-100 p-1 rounded" dir="ltr"><button onClick={() => setLang('java')} className={`px-2 py-1 text-[10px] font-bold rounded ${lang === 'java' ? 'bg-white shadow' : 'text-slate-500'}`}>JAVA</button><button onClick={() => setLang('csharp')} className={`px-2 py-1 text-[10px] font-bold rounded ${lang === 'csharp' ? 'bg-white shadow' : 'text-slate-500'}`}>C#</button></div>
            </header>
            <div className="flex-1 flex flex-col md:flex-row overflow-hidden relative">
                <aside className="flex-none w-full md:w-64 bg-white border-b md:border-r border-slate-200 flex flex-col z-40 max-h-[30vh] md:max-h-full overflow-y-auto">
                    <div className="p-4 space-y-6">
                        <div className="space-y-3">
                            <label className="text-xs font-bold text-slate-400 uppercase">Operation</label>
                            <select className="w-full p-2 border border-slate-300 rounded text-sm bg-white" value={selectedMethod} onChange={(e) => setSelectedMethod(e.target.value)} disabled={activeDS === DATA_STRUCTURES.BINARY_TREE}>
                                {OPS_CONFIG[activeDS]?.map(op => <option key={op.value} value={op.value}>{op.label}</option>)}
                            </select>
                            {activeDS !== DATA_STRUCTURES.BINARY_TREE && showValInput && <input type="number" placeholder="Value" className="w-full p-2 border rounded text-sm" value={inputVal} onChange={e => setInputVal(e.target.value)} />}
                            {activeDS !== DATA_STRUCTURES.BINARY_TREE && showTargetInput && <input type="number" placeholder="Target" className="w-full p-2 border rounded text-sm bg-orange-50" value={inputTarget} onChange={e => setInputTarget(e.target.value)} />}
                            <button onClick={runOperation} className={`${BTN_STYLES.primary} ${activeDS === DATA_STRUCTURES.BINARY_TREE ? 'opacity-50 cursor-not-allowed' : ''}`} disabled={activeDS === DATA_STRUCTURES.BINARY_TREE}>
                                <Play className="w-4 h-4" /> Run
                            </button>
                        </div>
                        <div className="space-y-3 pt-4 border-t border-slate-100"><div className="flex justify-between text-xs text-slate-500"><span>Speed</span><span>{playbackSpeed}ms</span></div><input type="range" min="100" max="2000" step="100" value={playbackSpeed} onChange={e => setPlaybackSpeed(Number(e.target.value))} className="w-full" /><div className="flex justify-center gap-2"><button className="p-2 hover:bg-slate-100 rounded" onClick={() => setCurrentFrameIndex(Math.max(0, currentFrameIndex-1))}><SkipBack className="w-4 h-4"/></button><button className="p-2 bg-indigo-100 text-indigo-700 rounded" onClick={() => setIsPlaying(!isPlaying)}>{isPlaying ? <Pause className="w-4 h-4"/> : <Play className="w-4 h-4"/>}</button><button className="p-2 hover:bg-slate-100 rounded" onClick={() => setCurrentFrameIndex(Math.min(frames.length-1, currentFrameIndex+1))}><SkipForward className="w-4 h-4"/></button></div></div>
                        <div className="grid grid-cols-2 gap-2 pt-4 border-t border-slate-100">
                            <button onClick={handleGenerate} disabled={activeDS === DATA_STRUCTURES.BINARY_TREE} className={`p-2 bg-emerald-50 text-emerald-600 rounded text-xs font-bold flex flex-col items-center ${activeDS === DATA_STRUCTURES.BINARY_TREE ? 'opacity-50 cursor-not-allowed' : ''}`}><PlusCircle className="w-4 h-4 mb-1"/>Gen</button>
                            <button onClick={handleClear} className="p-2 bg-red-50 text-red-600 rounded text-xs font-bold flex flex-col items-center"><Trash2 className="w-4 h-4 mb-1"/>Clear</button>
                        </div>
                    </div>
                </aside>
                <main className="flex-1 flex flex-col relative bg-slate-50/50 overflow-hidden">
                    <div className="absolute top-4 left-4 z-30 flex items-center gap-3"><span className="bg-white border border-slate-200 px-3 py-1 rounded-full text-xs font-bold shadow-sm text-slate-600">{statusMsg}</span></div>
                    <div className="flex-1 overflow-auto relative">{renderVisuals()}</div>
                    {activeDS !== DATA_STRUCTURES.BINARY_TREE && (
                        <div className="flex-none h-48 bg-[#1e1e1e] border-t border-slate-700 flex flex-col z-30 shadow-2xl">
                            <div className="px-4 py-2 bg-[#2d2d2d] flex justify-between items-center border-b border-black"><div className="flex items-center gap-2"><Code className="w-4 h-4 text-blue-400" /><span className="text-xs font-mono text-slate-300">Source Code</span></div><span className="text-[10px] text-slate-500 uppercase">{lang}</span></div>
                            <div className="flex-1 overflow-auto p-4 font-mono text-xs md:text-sm leading-relaxed">{safeCodeSnippet.split('\n').map((line, i) => (<div key={i} className={`flex ${frames[currentFrameIndex]?.highlightLine === i+1 ? 'bg-yellow-900/40 text-yellow-200' : 'text-slate-400'}`}><span className="w-8 text-right mr-4 select-none opacity-50">{i+1}</span><span className="whitespace-pre">{line}</span></div>))}</div>
                        </div>
                    )}
                </main>
            </div>
          </div>
        );
      }

      // ==========================================
      // MOUNT
      // ==========================================
      const root = createRoot(document.getElementById('root'));
      root.render(
        <React.StrictMode>
          <WrappedApp />
        </React.StrictMode>
      );
    </script>
</body>
</html>
